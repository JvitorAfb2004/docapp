import { NextApiRequest, NextApiResponse } from 'next';
import { verifyToken } from '../../../lib/auth';
import { getDecryptedOpenAIKey } from '../../../lib/encryption';
import db from '../../../models';
import fs from 'fs';
import path from 'path';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'M√©todo n√£o permitido' });
  }

  try {
    // Verificar autentica√ß√£o
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ error: 'Token n√£o fornecido' });
    }

    const decoded = verifyToken(token);
    if (!decoded) {
      return res.status(401).json({ error: 'Token inv√°lido' });
    }

    const { textoDFD, numeroBloco, resumoDFD, documentosApoio } = req.body;

    if (!textoDFD || !numeroBloco) {
      return res.status(400).json({ error: 'Texto do DFD e n√∫mero do bloco s√£o obrigat√≥rios' });
    }

    // Obter chave OpenAI
    const apiKey = await getDecryptedOpenAIKey(db);
    if (!apiKey) {
      throw new Error('Nenhuma chave OpenAI ativa encontrada');
    }

    // Carregar prompts verbatim
    const promptsPath = path.join(process.cwd(), 'documentos', 'prompts-verbatim-blocos.txt');
    const promptsContent = fs.readFileSync(promptsPath, 'utf8');

    // Extrair prompt espec√≠fico do bloco
    const blocoSection = extractBlocoPrompt(promptsContent, numeroBloco);
    if (!blocoSection) {
      return res.status(400).json({ error: 'Prompt n√£o encontrado para o bloco especificado' });
    }

    console.log(`ü§ñ Gerando Bloco ${numeroBloco} com prompt verbatim...`);

    // Preparar contexto completo
    let contextoCompleto = `DFD ANALISADO:\n${textoDFD}\n\n`;
    
    if (resumoDFD) {
      contextoCompleto += `RESUMO DO DFD:\n${JSON.stringify(resumoDFD, null, 2)}\n\n`;
    }

    if (documentosApoio && documentosApoio.length > 0) {
      contextoCompleto += `DOCUMENTOS DE APOIO:\n`;
      documentosApoio.forEach((doc, index) => {
        contextoCompleto += `Documento ${index + 1}: ${doc.conteudo}\n\n`;
      });
    }

    // Enviar para OpenAI
    const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'Voc√™ √© um especialista em Estudos T√©cnicos Preliminares (ETP) para contrata√ß√µes p√∫blicas brasileiras. Siga exatamente as instru√ß√µes fornecidas e retorne apenas o JSON solicitado.'
          },
          {
            role: 'user',
            content: `${blocoSection.promptTecnico}\n\n${blocoSection.promptResposta}\n\n${contextoCompleto}`
          }
        ],
        temperature: 0.3,
        max_tokens: 3000
      })
    });

    if (!openaiResponse.ok) {
      const error = await openaiResponse.text();
      console.error('‚ùå Erro na API OpenAI:', error);
      throw new Error(`Erro na API OpenAI: ${openaiResponse.statusText}`);
    }

    const result = await openaiResponse.json();
    const rawContent = result.choices[0]?.message?.content || '';

    console.log('‚úÖ Resposta da IA recebida para bloco', numeroBloco);

    // Tentar extrair JSON da resposta
    let dadosBloco;
    try {
      const jsonMatch = rawContent.match(/```json\s*([\s\S]*?)\s*```/) || 
                       rawContent.match(/{[\s\S]*}/);
      
      if (jsonMatch) {
        const jsonString = jsonMatch[1] || jsonMatch[0];
        dadosBloco = JSON.parse(jsonString);
        console.log('‚úÖ JSON parseado com sucesso para bloco', numeroBloco);
      } else {
        throw new Error('JSON n√£o encontrado na resposta');
      }
    } catch (parseError) {
      console.error('‚ùå Erro ao fazer parse do JSON para bloco', numeroBloco, ':', parseError);
      console.log('üìÑ Resposta completa da IA:', rawContent);
      
      // Fallback: criar estrutura b√°sica
      dadosBloco = createFallbackStructure(numeroBloco);
    }

    // Criar estrutura do bloco com perguntas estruturadas
    const bloco = {
      id: numeroBloco,
      titulo: blocoSection.titulo,
      perguntas: createPerguntasEstruturadas(dadosBloco, numeroBloco),
      conteudoGerado: rawContent,
      tipo: 'bloco',
      dataGeracao: new Date().toISOString()
    };

    res.status(200).json({
      success: true,
      bloco,
      message: `${blocoSection.titulo} gerado com sucesso`
    });

  } catch (error) {
    console.error('‚ùå Erro no processamento do bloco:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor',
      details: error.message 
    });
  }
}

// Fun√ß√£o para extrair prompt espec√≠fico do bloco
function extractBlocoPrompt(promptsContent, numeroBloco) {
  const blocos = {
    1: {
      titulo: 'Bloco 1 - Caracter√≠sticas Contratuais Fundamentais',
      promptTecnico: extractSection(promptsContent, '### PROMPT T√âCNICO:', '### PROMPT DE RESPOSTA:'),
      promptResposta: extractSection(promptsContent, '### PROMPT DE RESPOSTA:', '---')
    },
    2: {
      titulo: 'Bloco 2 - Requisitos T√©cnicos e Regulamentares',
      promptTecnico: extractSection(promptsContent, '## BLOCO 2 - REQUISITOS T√âCNICOS E REGULAMENTARES', '### PROMPT T√âCNICO:'),
      promptResposta: extractSection(promptsContent, '### PROMPT DE RESPOSTA:', '---')
    },
    3: {
      titulo: 'Bloco 3 - Dimensionamento Quantitativo',
      promptTecnico: extractSection(promptsContent, '## BLOCO 3 - DIMENSIONAMENTO QUANTITATIVO', '### PROMPT T√âCNICO:'),
      promptResposta: extractSection(promptsContent, '### PROMPT DE RESPOSTA:', '---')
    },
    4: {
      titulo: 'Bloco 4 - An√°lise de Mercado e Viabilidade',
      promptTecnico: extractSection(promptsContent, '## BLOCO 4 - AN√ÅLISE DE MERCADO E VIABILIDADE', '### PROMPT T√âCNICO:'),
      promptResposta: extractSection(promptsContent, '### PROMPT DE RESPOSTA:', '---')
    },
    5: {
      titulo: 'Bloco 5 - Solu√ß√£o T√©cnica Detalhada',
      promptTecnico: extractSection(promptsContent, '## BLOCO 5 - SOLU√á√ÉO T√âCNICA DETALHADA', '### PROMPT T√âCNICO:'),
      promptResposta: extractSection(promptsContent, '### PROMPT DE RESPOSTA:', '---')
    },
    6: {
      titulo: 'Bloco 6 - Resultados e Gest√£o',
      promptTecnico: extractSection(promptsContent, '## BLOCO 6 - RESULTADOS E GEST√ÉO', '### PROMPT T√âCNICO:'),
      promptResposta: extractSection(promptsContent, '### PROMPT DE RESPOSTA:', '---')
    },
    7: {
      titulo: 'Bloco 7 - Aspectos Complementares e Finaliza√ß√µes',
      promptTecnico: extractSection(promptsContent, '## BLOCO 7 - ASPECTOS COMPLEMENTARES E FINALIZA√á√ïES', '### PROMPT T√âCNICO:'),
      promptResposta: extractSection(promptsContent, '### PROMPT DE RESPOSTA:', '---')
    }
  };

  return blocos[numeroBloco];
}

// Fun√ß√£o para extrair se√ß√£o do texto
function extractSection(content, startMarker, endMarker) {
  const startIndex = content.indexOf(startMarker);
  if (startIndex === -1) {
    console.log(`Marcador n√£o encontrado: ${startMarker}`);
    return null;
  }

  const endIndex = content.indexOf(endMarker, startIndex);
  const section = content.substring(startIndex, endIndex === -1 ? content.length : endIndex);
  
  // Remover o marcador inicial e limpar
  let result = section.replace(startMarker, '').trim();
  
  // Se encontrou marcador final, remover tamb√©m
  if (endIndex !== -1) {
    result = result.replace(endMarker, '').trim();
  }
  
  return result;
}

// Fun√ß√£o para criar estrutura de fallback
function createFallbackStructure(numeroBloco) {
  const estruturas = {
    1: {
      tipoObjeto: 'Servi√ßo',
      vigenciaContrato: 'N√£o informado no DFD',
      prorrogacao: 'N√£o informado no DFD',
      naturezaContratacao: 'N√£o informado no DFD',
      fornecimentoContinuado: 'N√£o informado no DFD',
      enderecoCompleto: 'N√£o informado no DFD',
      protocoloPNCP: 'N√£o informado no DFD'
    },
    2: {
      sustentabilidade: 'N√£o informado no DFD',
      treinamento: 'N√£o informado no DFD',
      bemLuxo: 'N√£o informado no DFD',
      transicaoContratual: 'N√£o informado no DFD',
      normativosEspecificos: 'N√£o informado no DFD',
      amostra: 'N√£o informado no DFD',
      marcaEspecifica: 'N√£o informado no DFD',
      subcontratacao: 'N√£o informado no DFD'
    },
    3: {
      metodologiaQuantitativo: 'N√£o informado no DFD',
      descricaoDetalhada: 'N√£o informado no DFD',
      serieHistorica: 'N√£o informado no DFD',
      confirmacaoUnidades: 'N√£o informado no DFD'
    },
    4: {
      fontesPesquisa: 'N√£o informado no DFD',
      justificativaTecnica: 'N√£o informado no DFD',
      justificativaEconomica: 'N√£o informado no DFD',
      restricoesMercado: 'N√£o informado no DFD',
      tratamentoMEEPP: 'N√£o informado no DFD'
    },
    5: {
      pesquisaPrecos: 'N√£o informado no DFD',
      descricaoCompleta: 'N√£o informado no DFD',
      garantia: 'N√£o informado no DFD',
      assistenciaTecnica: 'N√£o informado no DFD',
      manutencao: 'N√£o informado no DFD',
      parcelamento: 'N√£o informado no DFD'
    },
    6: {
      beneficiosPretendidos: 'N√£o informado no DFD',
      notaExplicativa: 'N√£o informado no DFD',
      providenciasPendentes: 'N√£o informado no DFD',
      gestaoFiscalizacao: 'N√£o informado no DFD',
      contratacoesRelacionadas: 'N√£o informado no DFD'
    }
  };

  return estruturas[numeroBloco] || {};
}

// Fun√ß√£o para criar perguntas estruturadas baseadas no estudo de refer√™ncia
function createPerguntasEstruturadas(dadosBloco, numeroBloco) {
  const perguntas = [];
  
  // Mapeamento das perguntas por bloco baseado no estudo de refer√™ncia
  const perguntasPorBloco = {
    1: [
      { campo: 'tipoObjeto', label: 'Qual o tipo de objeto da contrata√ß√£o?', type: 'checkbox', opcoes: ['Bem', 'Servi√ßo'] },
      { campo: 'vigenciaContrato', label: 'Qual a vig√™ncia estimada do contrato?', type: 'text' },
      { campo: 'prorrogacao', label: '√â poss√≠vel prorrogar o contrato?', type: 'checkbox', opcoes: ['Sim', 'N√£o', 'N√£o se aplica'] },
      { campo: 'naturezaContratacao', label: 'Qual a natureza da contrata√ß√£o?', type: 'checkbox', opcoes: ['Continuada sem monop√≥lio', 'Continuada com monop√≥lio', 'N√£o continuada'] },
      { campo: 'fornecimentoContinuado', label: 'O fornecimento/servi√ßo √© continuado?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'enderecoCompleto', label: 'Qual o endere√ßo completo de execu√ß√£o?', type: 'text' },
      { campo: 'protocoloPNCP', label: 'Qual o n√∫mero do protocolo PNCP?', type: 'text' }
    ],
    2: [
      { campo: 'sustentabilidade', label: 'H√° crit√©rios de sustentabilidade aplic√°veis?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'treinamento', label: 'Haver√° necessidade de capacita√ß√£o/treinamento?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'bemLuxo', label: 'O objeto se caracteriza como bem de luxo (Decreto 10.818/2021)?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'transicaoContratual', label: 'Ser√° necess√°ria transi√ß√£o contratual?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'normativosEspecificos', label: 'H√° normativos espec√≠ficos aplic√°veis (NBR, NR, resolu√ß√µes)?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'amostra', label: 'Ser√° exigida amostra ou prova de conceito?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'marcaEspecifica', label: 'H√° exig√™ncia de marca espec√≠fica?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'subcontratacao', label: '√â permitida subcontrata√ß√£o?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] }
    ],
    3: [
      { campo: 'metodologiaQuantitativo', label: 'Qual a metodologia utilizada para o dimensionamento quantitativo?', type: 'text' },
      { campo: 'descricaoDetalhada', label: 'Como foi calculado o dimensionamento de cada item?', type: 'text' },
      { campo: 'serieHistorica', label: 'Existe s√©rie hist√≥rica de consumo/necessidade?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'confirmacaoUnidades', label: 'As unidades e quantidades est√£o corretas?', type: 'text' }
    ],
    4: [
      { campo: 'fontesPesquisa', label: 'Quais foram as fontes de pesquisa de mercado utilizadas?', type: 'text' },
      { campo: 'justificativaTecnica', label: 'Qual a justificativa t√©cnica da solu√ß√£o escolhida?', type: 'text' },
      { campo: 'justificativaEconomica', label: 'Qual a justificativa econ√¥mica da contrata√ß√£o?', type: 'text' },
      { campo: 'restricoesMercado', label: 'Existem restri√ß√µes no mercado fornecedor?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'tratamentoMEEPP', label: '√â aplic√°vel o tratamento diferenciado para ME/EPP?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] }
    ],
    5: [
      { campo: 'pesquisaPrecos', label: 'Qual a metodologia de pesquisa de pre√ßos utilizada?', type: 'text' },
      { campo: 'descricaoCompleta', label: 'Qual a descri√ß√£o completa da contrata√ß√£o?', type: 'text' },
      { campo: 'garantia', label: 'Quais os requisitos de garantia?', type: 'text' },
      { campo: 'assistenciaTecnica', label: '√â necess√°ria assist√™ncia t√©cnica?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'manutencao', label: '√â necess√°ria manuten√ß√£o?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'parcelamento', label: '√â poss√≠vel parcelar a contrata√ß√£o?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] }
    ],
    6: [
      { campo: 'beneficiosPretendidos', label: 'Quais os benef√≠cios pretendidos com a contrata√ß√£o?', type: 'text' },
      { campo: 'notaExplicativa', label: 'Qual a nota explicativa dos resultados esperados?', type: 'text' },
      { campo: 'providenciasPendentes', label: 'Existem provid√™ncias pendentes antes da contrata√ß√£o?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'gestaoFiscalizacao', label: 'Quais as compet√™ncias de gest√£o e fiscaliza√ß√£o do contrato?', type: 'text' },
      { campo: 'contratacoesRelacionadas', label: 'Existem contrata√ß√µes relacionadas?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] }
    ],
    7: [
      { campo: 'impactosAmbientais', label: 'H√° previs√£o de impactos ambientais?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'medidasMitigacao', label: 'Quais medidas de mitiga√ß√£o ambiental ser√£o adotadas?', type: 'text' },
      { campo: 'viabilidade', label: 'A contrata√ß√£o possui viabilidade t√©cnica, socioecon√¥mica e ambiental?', type: 'checkbox', opcoes: ['Sim', 'N√£o'] },
      { campo: 'posicionamentoConclusivo', label: 'Forne√ßa posicionamento conclusivo detalhado sobre a adequa√ß√£o da contrata√ß√£o.', type: 'text' },
      { campo: 'responsaveisTecnicos', label: 'Quem s√£o os respons√°veis t√©cnicos pela elabora√ß√£o do ETP?', type: 'text' },
      { campo: 'ordenadorDespesa', label: 'Quais os dados do ordenador de despesa?', type: 'text' }
    ]
  };

  const perguntasBloco = perguntasPorBloco[numeroBloco] || [];
  
  perguntasBloco.forEach((pergunta, index) => {
    const valor = dadosBloco[pergunta.campo] || '';
    
    // Determinar valor correto para checkbox
    let valorCheckbox = '';
    if (pergunta.type === 'checkbox') {
      if (pergunta.opcoes.includes(valor)) {
        valorCheckbox = valor;
      } else {
        // Se o valor n√£o est√° nas op√ß√µes, usar "N√£o" como padr√£o
        valorCheckbox = 'N√£o';
      }
    }
    
    const perguntaEstruturada = {
      id: `${numeroBloco}_${pergunta.campo}`,
      label: pergunta.label,
      type: pergunta.type,
      order: index + 1,
      opcoes: pergunta.opcoes || [],
      value: {
        text: pergunta.type === 'text' ? valor : '',
        checkbox: valorCheckbox
      }
    };
    
    perguntas.push(perguntaEstruturada);
  });

  return perguntas.sort((a, b) => a.order - b.order);
}

// Fun√ß√£o para formatar label
function formatLabel(campo) {
  return campo
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim();
}

// Fun√ß√£o para determinar tipo do campo
function determineType(campo, valor) {
  // Campos que devem ser checkbox
  const checkboxFields = [
    'sustentabilidade', 'treinamento', 'bemLuxo', 'transicaoContratual',
    'normativosEspecificos', 'amostra', 'marcaEspecifica', 'subcontratacao',
    'prorrogacao', 'fornecimentoContinuado', 'assistenciaTecnica', 'manutencao',
    'parcelamento', 'providenciasPendentes', 'contratacoesRelacionadas'
  ];

  if (checkboxFields.some(field => campo.toLowerCase().includes(field))) {
    return 'checkbox';
  }

  return 'text';
}
